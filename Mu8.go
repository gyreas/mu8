package main

import (
	"fmt"
	"log"
	"os"
	"time"
)

var ibm_logo []uint8 = []uint8{
	0x00, 0xe0, 0xa2, 0x2a, 0x60, 0x0c, 0x61, 0x08, 0xd0, 0x1f, 0x70, 0x09,
	0xa2, 0x39, 0xd0, 0x1f, 0xa2, 0x48, 0x70, 0x08, 0xd0, 0x1f, 0x70, 0x04,
	0xa2, 0x57, 0xd0, 0x1f, 0x70, 0x08, 0xa2, 0x66, 0xd0, 0x1f, 0x70, 0x08,
	0xa2, 0x75, 0xd0, 0x1f, 0x12, 0x28, 0xff, 0x00, 0xff, 0x00, 0x3c, 0x00,
	0x3c, 0x00, 0x3c, 0x00, 0x3c, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff,
	0x00, 0x38, 0x00, 0x3f, 0x00, 0x3f, 0x00, 0x38, 0x00, 0xff, 0x00, 0xff,
	0x80, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x00,
	0xe0, 0x00, 0x80, 0xf8, 0x00, 0xfc, 0x00, 0x3e, 0x00, 0x3f, 0x00, 0x3b,
	0x00, 0x39, 0x00, 0xf8, 0x00, 0xf8, 0x03, 0x00, 0x07, 0x00, 0x0f, 0x00,
	0xbf, 0x00, 0xfb, 0x00, 0xf3, 0x00, 0xe3, 0x00, 0x43, 0xe0, 0x00, 0xe0,
	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xe0, 0x00, 0xe0,
}
const CPU_HZ = 16 * time.Millisecond

type Mu8 struct {
	cpu   Cpu
	video Display

	romsz int
}

func (Mu8 *Mu8) load_rom(rom []uint8) {
	copy(Mu8.cpu.M[PROGRAM_ADDRESS_OFFSET:], rom)
	Mu8.romsz = len(rom)
}

const debug = true

func main() {
	log.Println("Mu8! go!")

	Mu8 := Mu8{}
	Mu8.cpu = NewCpu()

	Mu8.load_rom(ibm_logo)

	video := NewDisplay()

	go video.startRenderLoop()
	defer video.handleQuit()

	cpu := Mu8.cpu

cycle:
	for cpu.ip < MEMORY_SIZE {

		inst := cpu.fetch()
		logmsg("%.4x | [%.4x] ", cpu.ip-2, inst)

		cpu.decode_execute(&Mu8, inst, video.clear)

		if cpu.sprite != nil {
			x := int(cpu.sprite[0])
			y := int(cpu.sprite[1])
			pos := Vec2{x, y}

			video.smu.Lock()
			cpu.R[0x0f] = video.fb.drawSpriteAt(cpu.sprite[2:], pos)
			video.renderFb()
			video.screen.Show()
			video.smu.Unlock()

			logmsg("Rendered FB from Cpu\n")

			// invalidate the data
			cpu.sprite = nil

		}

		select {
		case <-video.quit:
			close(video.quit)
			break cycle
		default:
			<-time.After(CPU_HZ)
		}
	}
}

func logmsg(format string, args ...any) {
	if !debug {
		return
	}

	fmt.Fprintf(os.Stderr, format, args...)
}
